<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <canvas id="mosaic" width="400" height="400"> </canvas>
    <script>
      const canvas = document.getElementById("mosaic");
      const ctx = canvas.getContext("2d");
      const image = new Image();
      image.src = "./Test.png";

      image.onload = function () {
        if (!ctx) {
          return null;
        }
        canvas.width = image.width;
        canvas.height = image.height;
        draw();
      };

      const size = 40;

      const draw = () => {
        // 绘制原始图片
        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);
        // 获取原始图片信息
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // 生成 i * j 的马赛克块
        for (let i = 0; i < Math.floor(canvas.width / size); i++) {
          for (let j = 0; j < Math.floor(canvas.height / size); j++) {
            // 从马赛克块中随机抽出一个像素点信息
            let rgba = getPxInfo(
              imageData,
              i * size + Math.floor(Math.random() * size),
              j * size + Math.floor(Math.random() * size)
            );

            // 填充马赛克块
            fillMosaicRect(ctx, rgba, i * size, j * size, size, size);
          }
        }
      };

      const getPxInfo = (imgData, x, y) => {
        const color = [];
        const data = imgData.data;
        const w = imgData.width;
        color[0] = data[(y * w + x) * 4];
        color[1] = data[(y * w + x) * 4 + 1];
        color[2] = data[(y * w + x) * 4 + 2];
        color[3] = data[(y * w + x) * 4 + 3];
        return color;
      };

      const fillMosaicRect = (ctx, rgba, x, y, w, h) => {
        // 阴影效果
        ctx.shadowBlur = w / 4;
        ctx.shadowColor = `rgb(${rgba.map((color) => color * 0.6).join(",")})`;

        // 背景色
        ctx.fillStyle = `rgb(${rgba.join(",")})`;
        ctx.fillRect(x, y, w, h);

        // 浮雕背景色
        const lineargradient = ctx.createLinearGradient(x, y, x, y + h);
        lineargradient.addColorStop(0, `#ffffff`);
        lineargradient.addColorStop(0.5, `rgb(${rgba.join(",")})`);
        lineargradient.addColorStop(1, `#000000`);
        ctx.fillStyle = lineargradient;

        const circleFore = new Path2D();
        circleFore.arc(x + w / 2, y + h / 2, w / 3, 0, 2 * Math.PI);
        ctx.fill(circleFore);

        // 浮雕前景色
        ctx.fillStyle = `rgb(${rgba.join(",")})`;
        ctx.shadowBlur = 0;
        ctx.shadowColor = "";

        const circleBack = new Path2D();
        circleBack.arc(x + w / 2, y + h / 2, (w / 3) * 0.8, 0, 2 * Math.PI);
        ctx.fill(circleBack);
      };
    </script>
  </body>
</html>
